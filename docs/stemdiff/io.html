<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>stemdiff.io API documentation</title>
<meta name="description" content="stemdiff.io
Input/output functions for package stemdiff." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>stemdiff.io</code></h1>
</header>
<section id="section-intro">
<h2 id="stemdiffio">stemdiff.io</h2>
<p>Input/output functions for package stemdiff.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
stemdiff.io
-----------
Input/output functions for package stemdiff.    
&#39;&#39;&#39;

# The functions:
#  1) Manipulate with DAT-files: read, show-as-image,save-as-image...
#  2) Manipulate with ARRAYS: rescale, find_center, reduce_size... 
#  3) Manipulate with IMAGES: read/show an image...
# Note:
#  both dat-files and images are read and processed as numpy arrays.


import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
from skimage import transform, measure
from stemdiff.const import DET_SIZE

# ============================================================================
# 1st group of functions - manipulation with DATAFILES
# (read, show-as-image, save-as-image, show-series-of-datafiles

def read_datafile(filename):
    &#39;&#39;&#39;
    Read datafile from 2D-STEM detector into numpy array.
    Assumptions: 2D-STEM detector with dimensions DET_SIZE x DET_SIZE
    (where DET_FILE = stemdiff.const.DET_FILE = constant in stemdiff.const),
    which yields binary files with 16-bit intensity values.
    
    Parameters
    ----------
    filename : string or pathlib object
        Name of datafile from pixelated datector
        that should be read into numpy 2D array.
        
    Returns
    -------
    2D numpy array
    &#39;&#39;&#39;
    arr = np.fromfile(filename, dtype=np.uint16)
    arr = arr.reshape(DET_SIZE,DET_SIZE)
    return(arr)

def show_datafile(filename, intensity_cut=300):
    &#39;&#39;&#39;
    Show datafile = diffractogram from 2D-STEM detector;
    the datafile is shown as an image using matplotlib.pyplot.
    
    Parameters
    ----------
    filename : str or Path
        Name of datafile to be shown.
    intensity_cut : integer
        For all pixels: if intensity &gt; intensity_cut: intensity=intensity_cut;
        this reduces the strongest intensity of the central spot/primary beam.
        
    Returns
    -------
    Nothing; the output are the files and entropies shown on the screen.

    &#39;&#39;&#39;
    print(filename.name)
    # a) Read datafile
    arr = read_datafile(filename)
    # b) Calculated and print Shannon entropy of the datafile
    entropy_value = measure.shannon_entropy(arr)
    print(f&#39;Shannon entropy value = {entropy_value:.2f}&#39;)
    # c) Cut intensity and show datafile as 2D-image using matplotlib
    arr = np.where(arr&gt;intensity_cut, intensity_cut, arr)
    plt.imshow(arr, cmap=&#39;gray&#39;)
    plt.show()

def save_datafile(filename, output_image, intensity_cut=300, itype=&#39;8bit&#39;):
    &#39;&#39;&#39;
    Save datafile = diffractogram from 2D-STEM detector;
    the datafile is saved as a PNG-image using matplotlib.pyplot.
    
    Parameters
    ----------
    filename : str or Path
        Name of datafile to be shown.
    output_image : str
        Name of image to be saved (the full name will be output_image.png).
    intensity_cut : integer, optional, default=300
        For all pixels: if intensity &gt; intensity_cut: intensity=intensity_cut;
        this reduces the strongest intensity of the central spot/primary beam.
    itype : str (&#39;8bit&#39; or &#39;16bit&#39;), optional, default=&#39;8bit&#39;
         Type of the image: 8 or 16 bit grayscale. 
        
    Returns
    -------
    Nothing; the output is the saved PNG-image in active directory.

    &#39;&#39;&#39;
    print(filename.name)
    # a) Read datafile
    arr = read_datafile(filename)
    # b) Calculated and print Shannon entropy of the datafile
    entropy_value = measure.shannon_entropy(arr)
    print(f&#39;Shannon entropy value = {entropy_value:.2f}&#39;)
    # c) Cut intensity and save datafile as PNG-image using matplotlib
    arr = np.where(arr&gt;intensity_cut, intensity_cut, arr)
    # d) Before saving, normalize array according to itype = image_type
    if itype == &#39;8bit&#39;:
        arr = np.round(arr * (255/np.max(arr))).astype(dtype=np.uint8)
        img = Image.fromarray(arr, &#39;L&#39;)
    else:
        arr = arr.astype(&#39;uint16&#39;)
        img = Image.fromarray(arr)
    # e) Save the final (intensity-cut, normalized) datafile/array as image
    img.save(output_image) 
    
def show_datafiles(datafiles, intensity_cut=300):
    &#39;&#39;&#39;
    Show datafiles = diffractograms from 2D-STEM detector.
    The images and their calculated Shannon entropies are shown one by one.
    [Enter] = next file, [Ctrl+C] = end of show (a bit hardcore, but working).

    Parameters
    ----------
    datafiles : pathlib.glob object or iterable (list, array, iterator)
        Names of datafiles to be shown.
    intensity_cut : integer
        For all pixels: if intensity &gt; intensity_cut: intensity=intensity_cut;
        this reduces the strongest intensity of the central spot/primary beam.
        
    Returns
    -------
    Nothing; the output are the files and entropies shown on the screen.

    &#39;&#39;&#39;
    for datafile in datafiles:
        show_datafile(datafile, intensity_cut)
        input(&#39;[Enter] to continue...&#39;)

# ============================================================================
# 2nd group of functions - manipulation with ARRAYS
# (rescale, find_center, reduce_size, save-as-image

def rescale_array(arr,R):
    &#39;&#39;&#39;
    Rescale 2D numpy array (which represents an image).
    
    Parameters
    ----------
    arr : 2D numpy array
        Numpy array representing DAT-file/image.
    R : integer
        Rescale parameter: new_size_of the array = original_size * R

    Returns
    -------
    2D numpy array with new_size = original_size * R
    &#39;&#39;&#39;
    arr_max = np.max(arr)
    arr = transform.rescale(arr, R)
    arr = arr/np.max(arr) * arr_max
    return(arr)

def find_array_center(arr, central_square=None, central_intensity_coeff=None):
    &#39;&#39;&#39;
    Determine center of mass for 2D numpy array.
    Array center = mass center = intensity center ~ position of central spot.
    Note: for non-centrosymmetric images, central spot is NOT in array center.

    Parameters
    ----------
    arr : numpy 2D array
        Numpy 2D array, whose center (of mass ~ intensity) we want to get.
    central_square: integer, optional
        Edge of central square, from which the center will be determined.
    central_intensity_coeff: float, optional, interval: 0--1
        The intensity &lt; maximum_intensity * central_intensity_coeff
        is regarded as 0 (background removal in central square).
    Returns
    -------
    xc,yc = integers
        Coordinates of the array center.
    &#39;&#39;&#39;
    # Calculate center of array
    if central_square:
        # If central_square was given,
        # calculate center only for the square in the center,
        # in which we set background intensity = 0 to get correct results.
        # a) Calculate array corresponding to central square
        xsize,ysize = arr.shape
        xborder = (xsize - central_square) // 2
        yborder = (ysize - central_square) // 2
        arr2 = arr[xborder:-xborder,yborder:-yborder].copy()
        # b) Set intensity lower than maximum*coeff to 0 (background removal)
        coeff = central_intensity_coeff or 0.8
        arr2 = np.where(arr2&gt;np.max(arr2)*coeff, arr2, 0)
        # c) Calculate center of intensity (and add borders at the end)
        M = measure.moments(arr2,1)
        (xc,yc) = (M[1,0]/M[0,0], M[0,1]/M[0,0])
        (xc,yc) = (xc+xborder,yc+yborder)
        (xc,yc) = np.round([xc,yc],2)
    else:
        # If central_square was not given,
        # calculate center for the whole array.
        # =&gt; Wrong position of central spot for non-centrosymmetric images!
        M = measure.moments(arr,1)
        (xc,yc) = (M[1,0]/M[0,0], M[0,1]/M[0,0])
        (xc,yc) = np.round([xc,yc],2)
    # Return final values            
    return(xc,yc)

def reduce_array_size(arr,rsize,xc,yc):
    &#39;&#39;&#39;
    The original size is cut to rsize, center of new array is in xc,yc.

    Reduce/cut size of 2D numpy array.
    Parameters
    ----------
    arr : numpy 2D array
        The original array, whose size should be reduced.
    rsize : integer
        The size of reduced array.
    xc,yc : integers
        The center of original array;
        the reduced array is cut to rsize, center of new array is in xc,yc.

    Returns
    -------
    2D numpy array
        The array with reduced size.
    &#39;&#39;&#39;
    halfsize = int(rsize/2)
    if (rsize % 2) == 0:
        arr = arr[xc-halfsize:xc+halfsize, yc-halfsize:yc+halfsize]
    else:
        arr = arr[xc-halfsize:xc+halfsize+1, yc-halfsize:yc+halfsize+1]
    return(arr)

def save_array(arr, output_image, icut=None, itype=&#39;8bit&#39;, R=None):
    &#39;&#39;&#39;
    Save 2D numpy array as grayscale image.
    
    Parameters
    ----------
    arr : 2D numpy array
        array or image object to save
    output_image : string or pathlib object
        name of the output/saved file
    icut : integer
        Cut of intensity;
        if icut = 300, all image intensities &gt; 300 will be equal to 300.
    itype: string (&#39;8bit&#39;  or &#39;16bit&#39;)
        type of the image: 8 or 16 bit grayscale   
    R: integer
        Rescale coefficient;
        the input array is rescaled/enlarged R-times.
        For typical 2D-STEM detector with size 256x256 pixels,
        the array should be saved with R = 2 (or 4)
        in order to get sufficiently large image for further processing.

    Returns
    -------
    Nothing; the output is [output_image] saved on disk.
    &#39;&#39;&#39;
    # Cut intensity
    if icut:
        arr = np.where(arr&gt;icut, icut, arr)
    # Rescale
    if R:
        arr_max = np.max(arr)
        arr = transform.rescale(arr, R)
        arr = arr/np.max(arr) * arr_max
    # Prepare image object for saving
    if itype == &#39;8bit&#39;:
        arr = np.round(arr * (255/np.max(arr))).astype(dtype=np.uint8)
        img = Image.fromarray(arr, &#39;L&#39;)
    else:
        arr = arr.astype(&#39;uint16&#39;)
        img = Image.fromarray(arr)
    # Save image
    img.save(output_image)

# ============================================================================
# 3rd group of functions - manipulation with IMAGES
# (read/show an image

def read_image(image_name, itype=&#39;8bit&#39;):
    &#39;&#39;&#39;
    Read grayscale image into 2D numpy array.
    
    Parameters
    ----------
    image_name : string or pathlib object
        Name of image that should read into numpy 2D array.
    itype: string (&#39;8bit&#39;  or &#39;16bit&#39;)
        type of the image: 8 or 16 bit grayscale    
        
    Returns
    -------
    2D numpy array
    &#39;&#39;&#39;
    img = Image.open(image_name)
    if itype==&#39;8bit&#39;:
        arr = np.asarray(img, dtype=np.uint8)
    else:
        arr = np.asarray(img, dtype=np.uint16)
    return(arr)

def show_image(image_name, itype=&#39;8bit&#39;, cmap=&#39;gray&#39;):
    &#39;&#39;&#39;
    Read and display image from disk.

    Parameters
    ----------
    image_name : string or pathlib object
        name of the image to display
    itype : string (&#39;8bit&#39;  or &#39;16bit&#39;)
        type of the image: 8 or 16 bit grayscale
    cmap : string
        colormap (any colormap know to matplotlib)

    Returns
    -------
    Nothing; the output is image shown on screen.
    &#39;&#39;&#39;
    arr = read_image(image_name, itype=itype)
    plt.imshow(arr, cmap=cmap)
    plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="stemdiff.io.find_array_center"><code class="name flex">
<span>def <span class="ident">find_array_center</span></span>(<span>arr, central_square=None, central_intensity_coeff=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine center of mass for 2D numpy array.
Array center = mass center = intensity center ~ position of central spot.
Note: for non-centrosymmetric images, central spot is NOT in array center.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>numpy 2D array</code></dt>
<dd>Numpy 2D array, whose center (of mass ~ intensity) we want to get.</dd>
<dt><strong><code>central_square</code></strong> :&ensp;<code>integer</code>, optional</dt>
<dd>Edge of central square, from which the center will be determined.</dd>
<dt><strong><code>central_intensity_coeff</code></strong> :&ensp;<code>float</code>, optional<code>, interval: 0--1</code></dt>
<dd>The intensity &lt; maximum_intensity * central_intensity_coeff
is regarded as 0 (background removal in central square).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xc,yc = integers</code></dt>
<dd>Coordinates of the array center.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_array_center(arr, central_square=None, central_intensity_coeff=None):
    &#39;&#39;&#39;
    Determine center of mass for 2D numpy array.
    Array center = mass center = intensity center ~ position of central spot.
    Note: for non-centrosymmetric images, central spot is NOT in array center.

    Parameters
    ----------
    arr : numpy 2D array
        Numpy 2D array, whose center (of mass ~ intensity) we want to get.
    central_square: integer, optional
        Edge of central square, from which the center will be determined.
    central_intensity_coeff: float, optional, interval: 0--1
        The intensity &lt; maximum_intensity * central_intensity_coeff
        is regarded as 0 (background removal in central square).
    Returns
    -------
    xc,yc = integers
        Coordinates of the array center.
    &#39;&#39;&#39;
    # Calculate center of array
    if central_square:
        # If central_square was given,
        # calculate center only for the square in the center,
        # in which we set background intensity = 0 to get correct results.
        # a) Calculate array corresponding to central square
        xsize,ysize = arr.shape
        xborder = (xsize - central_square) // 2
        yborder = (ysize - central_square) // 2
        arr2 = arr[xborder:-xborder,yborder:-yborder].copy()
        # b) Set intensity lower than maximum*coeff to 0 (background removal)
        coeff = central_intensity_coeff or 0.8
        arr2 = np.where(arr2&gt;np.max(arr2)*coeff, arr2, 0)
        # c) Calculate center of intensity (and add borders at the end)
        M = measure.moments(arr2,1)
        (xc,yc) = (M[1,0]/M[0,0], M[0,1]/M[0,0])
        (xc,yc) = (xc+xborder,yc+yborder)
        (xc,yc) = np.round([xc,yc],2)
    else:
        # If central_square was not given,
        # calculate center for the whole array.
        # =&gt; Wrong position of central spot for non-centrosymmetric images!
        M = measure.moments(arr,1)
        (xc,yc) = (M[1,0]/M[0,0], M[0,1]/M[0,0])
        (xc,yc) = np.round([xc,yc],2)
    # Return final values            
    return(xc,yc)</code></pre>
</details>
</dd>
<dt id="stemdiff.io.read_datafile"><code class="name flex">
<span>def <span class="ident">read_datafile</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Read datafile from 2D-STEM detector into numpy array.
Assumptions: 2D-STEM detector with dimensions DET_SIZE x DET_SIZE
(where DET_FILE = stemdiff.const.DET_FILE = constant in stemdiff.const),
which yields binary files with 16-bit intensity values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code> or <code>pathlib object</code></dt>
<dd>Name of datafile from pixelated datector
that should be read into numpy 2D array.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>2D numpy array</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_datafile(filename):
    &#39;&#39;&#39;
    Read datafile from 2D-STEM detector into numpy array.
    Assumptions: 2D-STEM detector with dimensions DET_SIZE x DET_SIZE
    (where DET_FILE = stemdiff.const.DET_FILE = constant in stemdiff.const),
    which yields binary files with 16-bit intensity values.
    
    Parameters
    ----------
    filename : string or pathlib object
        Name of datafile from pixelated datector
        that should be read into numpy 2D array.
        
    Returns
    -------
    2D numpy array
    &#39;&#39;&#39;
    arr = np.fromfile(filename, dtype=np.uint16)
    arr = arr.reshape(DET_SIZE,DET_SIZE)
    return(arr)</code></pre>
</details>
</dd>
<dt id="stemdiff.io.read_image"><code class="name flex">
<span>def <span class="ident">read_image</span></span>(<span>image_name, itype='8bit')</span>
</code></dt>
<dd>
<div class="desc"><p>Read grayscale image into 2D numpy array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image_name</code></strong> :&ensp;<code>string</code> or <code>pathlib object</code></dt>
<dd>Name of image that should read into numpy 2D array.</dd>
<dt><strong><code>itype</code></strong> :&ensp;<code>string ('8bit'</code>
or <code>'16bit')</code></dt>
<dd>type of the image: 8 or 16 bit grayscale</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>2D numpy array</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_image(image_name, itype=&#39;8bit&#39;):
    &#39;&#39;&#39;
    Read grayscale image into 2D numpy array.
    
    Parameters
    ----------
    image_name : string or pathlib object
        Name of image that should read into numpy 2D array.
    itype: string (&#39;8bit&#39;  or &#39;16bit&#39;)
        type of the image: 8 or 16 bit grayscale    
        
    Returns
    -------
    2D numpy array
    &#39;&#39;&#39;
    img = Image.open(image_name)
    if itype==&#39;8bit&#39;:
        arr = np.asarray(img, dtype=np.uint8)
    else:
        arr = np.asarray(img, dtype=np.uint16)
    return(arr)</code></pre>
</details>
</dd>
<dt id="stemdiff.io.reduce_array_size"><code class="name flex">
<span>def <span class="ident">reduce_array_size</span></span>(<span>arr, rsize, xc, yc)</span>
</code></dt>
<dd>
<div class="desc"><p>The original size is cut to rsize, center of new array is in xc,yc.</p>
<p>Reduce/cut size of 2D numpy array.
Parameters</p>
<hr>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>numpy 2D array</code></dt>
<dd>The original array, whose size should be reduced.</dd>
<dt><strong><code>rsize</code></strong> :&ensp;<code>integer</code></dt>
<dd>The size of reduced array.</dd>
</dl>
<p>xc,yc : integers
The center of original array;
the reduced array is cut to rsize, center of new array is in xc,yc.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>2D numpy array</code></dt>
<dd>The array with reduced size.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_array_size(arr,rsize,xc,yc):
    &#39;&#39;&#39;
    The original size is cut to rsize, center of new array is in xc,yc.

    Reduce/cut size of 2D numpy array.
    Parameters
    ----------
    arr : numpy 2D array
        The original array, whose size should be reduced.
    rsize : integer
        The size of reduced array.
    xc,yc : integers
        The center of original array;
        the reduced array is cut to rsize, center of new array is in xc,yc.

    Returns
    -------
    2D numpy array
        The array with reduced size.
    &#39;&#39;&#39;
    halfsize = int(rsize/2)
    if (rsize % 2) == 0:
        arr = arr[xc-halfsize:xc+halfsize, yc-halfsize:yc+halfsize]
    else:
        arr = arr[xc-halfsize:xc+halfsize+1, yc-halfsize:yc+halfsize+1]
    return(arr)</code></pre>
</details>
</dd>
<dt id="stemdiff.io.rescale_array"><code class="name flex">
<span>def <span class="ident">rescale_array</span></span>(<span>arr, R)</span>
</code></dt>
<dd>
<div class="desc"><p>Rescale 2D numpy array (which represents an image).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>2D numpy array</code></dt>
<dd>Numpy array representing DAT-file/image.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>integer</code></dt>
<dd>Rescale parameter: new_size_of the array = original_size * R</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>2D numpy array with new_size = original_size * R</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rescale_array(arr,R):
    &#39;&#39;&#39;
    Rescale 2D numpy array (which represents an image).
    
    Parameters
    ----------
    arr : 2D numpy array
        Numpy array representing DAT-file/image.
    R : integer
        Rescale parameter: new_size_of the array = original_size * R

    Returns
    -------
    2D numpy array with new_size = original_size * R
    &#39;&#39;&#39;
    arr_max = np.max(arr)
    arr = transform.rescale(arr, R)
    arr = arr/np.max(arr) * arr_max
    return(arr)</code></pre>
</details>
</dd>
<dt id="stemdiff.io.save_array"><code class="name flex">
<span>def <span class="ident">save_array</span></span>(<span>arr, output_image, icut=None, itype='8bit', R=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save 2D numpy array as grayscale image.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>2D numpy array</code></dt>
<dd>array or image object to save</dd>
<dt><strong><code>output_image</code></strong> :&ensp;<code>string</code> or <code>pathlib object</code></dt>
<dd>name of the output/saved file</dd>
<dt><strong><code>icut</code></strong> :&ensp;<code>integer</code></dt>
<dd>Cut of intensity;
if icut = 300, all image intensities &gt; 300 will be equal to 300.</dd>
<dt><strong><code>itype</code></strong> :&ensp;<code>string ('8bit'</code>
or <code>'16bit')</code></dt>
<dd>type of the image: 8 or 16 bit grayscale</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>integer</code></dt>
<dd>Rescale coefficient;
the input array is rescaled/enlarged R-times.
For typical 2D-STEM detector with size 256x256 pixels,
the array should be saved with R = 2 (or 4)
in order to get sufficiently large image for further processing.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing; the output is [output_image] saved on disk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_array(arr, output_image, icut=None, itype=&#39;8bit&#39;, R=None):
    &#39;&#39;&#39;
    Save 2D numpy array as grayscale image.
    
    Parameters
    ----------
    arr : 2D numpy array
        array or image object to save
    output_image : string or pathlib object
        name of the output/saved file
    icut : integer
        Cut of intensity;
        if icut = 300, all image intensities &gt; 300 will be equal to 300.
    itype: string (&#39;8bit&#39;  or &#39;16bit&#39;)
        type of the image: 8 or 16 bit grayscale   
    R: integer
        Rescale coefficient;
        the input array is rescaled/enlarged R-times.
        For typical 2D-STEM detector with size 256x256 pixels,
        the array should be saved with R = 2 (or 4)
        in order to get sufficiently large image for further processing.

    Returns
    -------
    Nothing; the output is [output_image] saved on disk.
    &#39;&#39;&#39;
    # Cut intensity
    if icut:
        arr = np.where(arr&gt;icut, icut, arr)
    # Rescale
    if R:
        arr_max = np.max(arr)
        arr = transform.rescale(arr, R)
        arr = arr/np.max(arr) * arr_max
    # Prepare image object for saving
    if itype == &#39;8bit&#39;:
        arr = np.round(arr * (255/np.max(arr))).astype(dtype=np.uint8)
        img = Image.fromarray(arr, &#39;L&#39;)
    else:
        arr = arr.astype(&#39;uint16&#39;)
        img = Image.fromarray(arr)
    # Save image
    img.save(output_image)</code></pre>
</details>
</dd>
<dt id="stemdiff.io.save_datafile"><code class="name flex">
<span>def <span class="ident">save_datafile</span></span>(<span>filename, output_image, intensity_cut=300, itype='8bit')</span>
</code></dt>
<dd>
<div class="desc"><p>Save datafile = diffractogram from 2D-STEM detector;
the datafile is saved as a PNG-image using matplotlib.pyplot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>Name of datafile to be shown.</dd>
<dt><strong><code>output_image</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of image to be saved (the full name will be output_image.png).</dd>
<dt><strong><code>intensity_cut</code></strong> :&ensp;<code>integer</code>, optional, default=<code>300</code></dt>
<dd>For all pixels: if intensity &gt; intensity_cut: intensity=intensity_cut;
this reduces the strongest intensity of the central spot/primary beam.</dd>
<dt><strong><code>itype</code></strong> :&ensp;<code>str ('8bit'</code> or <code>'16bit')</code>, optional, default=<code>'8bit'</code></dt>
<dd>Type of the image: 8 or 16 bit grayscale.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing; the output is the saved PNG-image in active directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_datafile(filename, output_image, intensity_cut=300, itype=&#39;8bit&#39;):
    &#39;&#39;&#39;
    Save datafile = diffractogram from 2D-STEM detector;
    the datafile is saved as a PNG-image using matplotlib.pyplot.
    
    Parameters
    ----------
    filename : str or Path
        Name of datafile to be shown.
    output_image : str
        Name of image to be saved (the full name will be output_image.png).
    intensity_cut : integer, optional, default=300
        For all pixels: if intensity &gt; intensity_cut: intensity=intensity_cut;
        this reduces the strongest intensity of the central spot/primary beam.
    itype : str (&#39;8bit&#39; or &#39;16bit&#39;), optional, default=&#39;8bit&#39;
         Type of the image: 8 or 16 bit grayscale. 
        
    Returns
    -------
    Nothing; the output is the saved PNG-image in active directory.

    &#39;&#39;&#39;
    print(filename.name)
    # a) Read datafile
    arr = read_datafile(filename)
    # b) Calculated and print Shannon entropy of the datafile
    entropy_value = measure.shannon_entropy(arr)
    print(f&#39;Shannon entropy value = {entropy_value:.2f}&#39;)
    # c) Cut intensity and save datafile as PNG-image using matplotlib
    arr = np.where(arr&gt;intensity_cut, intensity_cut, arr)
    # d) Before saving, normalize array according to itype = image_type
    if itype == &#39;8bit&#39;:
        arr = np.round(arr * (255/np.max(arr))).astype(dtype=np.uint8)
        img = Image.fromarray(arr, &#39;L&#39;)
    else:
        arr = arr.astype(&#39;uint16&#39;)
        img = Image.fromarray(arr)
    # e) Save the final (intensity-cut, normalized) datafile/array as image
    img.save(output_image) </code></pre>
</details>
</dd>
<dt id="stemdiff.io.show_datafile"><code class="name flex">
<span>def <span class="ident">show_datafile</span></span>(<span>filename, intensity_cut=300)</span>
</code></dt>
<dd>
<div class="desc"><p>Show datafile = diffractogram from 2D-STEM detector;
the datafile is shown as an image using matplotlib.pyplot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>Name of datafile to be shown.</dd>
<dt><strong><code>intensity_cut</code></strong> :&ensp;<code>integer</code></dt>
<dd>For all pixels: if intensity &gt; intensity_cut: intensity=intensity_cut;
this reduces the strongest intensity of the central spot/primary beam.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing; the output are the files and entropies shown on the screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_datafile(filename, intensity_cut=300):
    &#39;&#39;&#39;
    Show datafile = diffractogram from 2D-STEM detector;
    the datafile is shown as an image using matplotlib.pyplot.
    
    Parameters
    ----------
    filename : str or Path
        Name of datafile to be shown.
    intensity_cut : integer
        For all pixels: if intensity &gt; intensity_cut: intensity=intensity_cut;
        this reduces the strongest intensity of the central spot/primary beam.
        
    Returns
    -------
    Nothing; the output are the files and entropies shown on the screen.

    &#39;&#39;&#39;
    print(filename.name)
    # a) Read datafile
    arr = read_datafile(filename)
    # b) Calculated and print Shannon entropy of the datafile
    entropy_value = measure.shannon_entropy(arr)
    print(f&#39;Shannon entropy value = {entropy_value:.2f}&#39;)
    # c) Cut intensity and show datafile as 2D-image using matplotlib
    arr = np.where(arr&gt;intensity_cut, intensity_cut, arr)
    plt.imshow(arr, cmap=&#39;gray&#39;)
    plt.show()</code></pre>
</details>
</dd>
<dt id="stemdiff.io.show_datafiles"><code class="name flex">
<span>def <span class="ident">show_datafiles</span></span>(<span>datafiles, intensity_cut=300)</span>
</code></dt>
<dd>
<div class="desc"><p>Show datafiles = diffractograms from 2D-STEM detector.
The images and their calculated Shannon entropies are shown one by one.
[Enter] = next file, [Ctrl+C] = end of show (a bit hardcore, but working).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>datafiles</code></strong> :&ensp;<code>pathlib.glob object</code> or <code>iterable (list, array, iterator)</code></dt>
<dd>Names of datafiles to be shown.</dd>
<dt><strong><code>intensity_cut</code></strong> :&ensp;<code>integer</code></dt>
<dd>For all pixels: if intensity &gt; intensity_cut: intensity=intensity_cut;
this reduces the strongest intensity of the central spot/primary beam.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing; the output are the files and entropies shown on the screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_datafiles(datafiles, intensity_cut=300):
    &#39;&#39;&#39;
    Show datafiles = diffractograms from 2D-STEM detector.
    The images and their calculated Shannon entropies are shown one by one.
    [Enter] = next file, [Ctrl+C] = end of show (a bit hardcore, but working).

    Parameters
    ----------
    datafiles : pathlib.glob object or iterable (list, array, iterator)
        Names of datafiles to be shown.
    intensity_cut : integer
        For all pixels: if intensity &gt; intensity_cut: intensity=intensity_cut;
        this reduces the strongest intensity of the central spot/primary beam.
        
    Returns
    -------
    Nothing; the output are the files and entropies shown on the screen.

    &#39;&#39;&#39;
    for datafile in datafiles:
        show_datafile(datafile, intensity_cut)
        input(&#39;[Enter] to continue...&#39;)</code></pre>
</details>
</dd>
<dt id="stemdiff.io.show_image"><code class="name flex">
<span>def <span class="ident">show_image</span></span>(<span>image_name, itype='8bit', cmap='gray')</span>
</code></dt>
<dd>
<div class="desc"><p>Read and display image from disk.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image_name</code></strong> :&ensp;<code>string</code> or <code>pathlib object</code></dt>
<dd>name of the image to display</dd>
<dt><strong><code>itype</code></strong> :&ensp;<code>string ('8bit'</code>
or <code>'16bit')</code></dt>
<dd>type of the image: 8 or 16 bit grayscale</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>string</code></dt>
<dd>colormap (any colormap know to matplotlib)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing; the output is image shown on screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_image(image_name, itype=&#39;8bit&#39;, cmap=&#39;gray&#39;):
    &#39;&#39;&#39;
    Read and display image from disk.

    Parameters
    ----------
    image_name : string or pathlib object
        name of the image to display
    itype : string (&#39;8bit&#39;  or &#39;16bit&#39;)
        type of the image: 8 or 16 bit grayscale
    cmap : string
        colormap (any colormap know to matplotlib)

    Returns
    -------
    Nothing; the output is image shown on screen.
    &#39;&#39;&#39;
    arr = read_image(image_name, itype=itype)
    plt.imshow(arr, cmap=cmap)
    plt.show()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#stemdiffio">stemdiff.io</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="stemdiff" href="index.html">stemdiff</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="stemdiff.io.find_array_center" href="#stemdiff.io.find_array_center">find_array_center</a></code></li>
<li><code><a title="stemdiff.io.read_datafile" href="#stemdiff.io.read_datafile">read_datafile</a></code></li>
<li><code><a title="stemdiff.io.read_image" href="#stemdiff.io.read_image">read_image</a></code></li>
<li><code><a title="stemdiff.io.reduce_array_size" href="#stemdiff.io.reduce_array_size">reduce_array_size</a></code></li>
<li><code><a title="stemdiff.io.rescale_array" href="#stemdiff.io.rescale_array">rescale_array</a></code></li>
<li><code><a title="stemdiff.io.save_array" href="#stemdiff.io.save_array">save_array</a></code></li>
<li><code><a title="stemdiff.io.save_datafile" href="#stemdiff.io.save_datafile">save_datafile</a></code></li>
<li><code><a title="stemdiff.io.show_datafile" href="#stemdiff.io.show_datafile">show_datafile</a></code></li>
<li><code><a title="stemdiff.io.show_datafiles" href="#stemdiff.io.show_datafiles">show_datafiles</a></code></li>
<li><code><a title="stemdiff.io.show_image" href="#stemdiff.io.show_image">show_image</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>